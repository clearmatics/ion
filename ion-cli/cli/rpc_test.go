// Copyright (c) 2018 Clearmatics Technologies Ltd
package cli

import (
	"encoding/hex"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"testing"

	"github.com/ethereum/go-ethereum/core/types"
	"github.com/stretchr/testify/assert"
)

func Test_EncodeSignedBlock(t *testing.T) {
	TestSigned := "f9025ca03471555ab9a99528f02f9cdd8f0017fe2f56e01116acc4fe7f78aee900442f35a01dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347940000000000000000000000000000000000000000a0f526f481ffb6c3c56956d596f2b23e1f7ff17c810ba59efb579d9334a1765444a007f36c7ad26564fa65daebda75a23dfa95d660199092510743f6c8527dd72586a0907121bec78b40e8256fac47867d955c560b321e93fc9f046f919ffb5e3823ffb90100224400000200000900000000000000000410000800000080000880000800000002000004000008000000000000004000000000000000000000100000080201020000000000000800000000088000000000000220000000040000000100000000000800000006204004401000102004000820000000000000800400100001000200200000000000000800800000010000000001000004004800000000020000000020000800180000081080001000000000000000000200000500100010040000000001020000400040000000000000000000000044000000000000000000000002080000000004000082000200000040224000000000040002008480000000000283288c8e837295a1832bffa2845b4f6b1db861d68301080d846765746886676f312e3130856c696e7578000000000000000000583a78dd245604e57368cb2688e42816ebc86eff73ee219dd96b8a56ea6392f75507e703203bc2cc624ce6820987cf9e8324dd1f9f67575502fe6060d723d0e100a00000000000000000000000000000000000000000000000000000000000000000880000000000000000"
	ExpectedSignedBytes, _ := hex.DecodeString(TestSigned)

	// read a fake block
	raw, err := ioutil.ReadFile("./block.json")
	if err != nil {
		fmt.Println("cannot find test block.json file:", err)
		return
	}

	// Marshall fake block into the Header
	var blockHeader *types.Header
	json.Unmarshal(raw, &blockHeader)
	SignedBlock := encodeSignedBlock(blockHeader)

	assert.Equal(t, ExpectedSignedBytes, SignedBlock)
}

func Test_EncodeUnsignedBlock(t *testing.T) {
	TestUnsigned := "f9021aa03471555ab9a99528f02f9cdd8f0017fe2f56e01116acc4fe7f78aee900442f35a01dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347940000000000000000000000000000000000000000a0f526f481ffb6c3c56956d596f2b23e1f7ff17c810ba59efb579d9334a1765444a007f36c7ad26564fa65daebda75a23dfa95d660199092510743f6c8527dd72586a0907121bec78b40e8256fac47867d955c560b321e93fc9f046f919ffb5e3823ffb90100224400000200000900000000000000000410000800000080000880000800000002000004000008000000000000004000000000000000000000100000080201020000000000000800000000088000000000000220000000040000000100000000000800000006204004401000102004000820000000000000800400100001000200200000000000000800800000010000000001000004004800000000020000000020000800180000081080001000000000000000000200000500100010040000000001020000400040000000000000000000000044000000000000000000000002080000000004000082000200000040224000000000040002008480000000000283288c8e837295a1832bffa2845b4f6b1da0d68301080d846765746886676f312e3130856c696e7578000000000000000000a00000000000000000000000000000000000000000000000000000000000000000880000000000000000"
	ExpectedUnsignedBytes, _ := hex.DecodeString(TestUnsigned)

	// read a fake block
	raw, err := ioutil.ReadFile("./block.json")
	if err != nil {
		fmt.Println("cannot find test block.json file:", err)
		return
	}

	// Marshall fake block into the Header
	var blockHeader *types.Header
	json.Unmarshal(raw, &blockHeader)
	UnsignedBlock := encodeUnsignedBlock(blockHeader)

	assert.Equal(t, ExpectedUnsignedBytes, UnsignedBlock)

}
